using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AdventOfCode.PathFinding
{
    internal class DijkstraModified
    {
        // Generated by ChatGPT
        // was apparently so efficient that it managed to find a path better than AdventOfCode 2015-08 solution code
        // checked the path manually and it was correct..... lol

        internal class Connection
        {
            internal int id;
            internal string origin;
            internal string destination;
            internal int distance;
            internal Connection(int _id, string _origin, string _destination, int _distance)
            {
                id = _id;
                origin = _origin;
                destination = _destination;
                distance = _distance;
            }
        }

        internal class Location
        {
            internal string id;
            internal string name;
            internal List<Connection> connections;
            internal bool visited = false;
            internal Location(string _id) { id = _id; name = id; connections = new List<Connection>(); }
        }

        internal class Route
        {
            public List<Location> Path = new();
            public int TotalDistance;

            public override string ToString()
            {
                return string.Join(" -> ", Path.Select(p => p.id)) +
                       $"  (distance {TotalDistance})";
            }
        }

        internal class ShortestRouteSolver
        {
            private Dictionary<string, Location> locations;
            private List<string> idList;
            private Dictionary<string, int> index;

            public ShortestRouteSolver(Dictionary<string, Location> locations)
            {
                this.locations = locations;
                idList = locations.Keys.ToList();
                index = idList
                    .Select((id, i) => (id, i))
                    .ToDictionary(t => t.id, t => t.i);
            }

            private record State(string Id, int Mask);

            public Route FindShortestRoute()
            {
                int n = idList.Count;
                int FULL = (1 << n) - 1;

                var pq = new PriorityQueue<State, int>();
                var dist = new Dictionary<State, int>();
                var parent = new Dictionary<State, State>();
                var parentConn = new Dictionary<State, Connection>();

                // Start from every location
                foreach (var id in idList)
                {
                    int mask = 1 << index[id];
                    var st = new State(id, mask);

                    pq.Enqueue(st, 0);
                    dist[st] = 0;
                }

                State finalState = null;

                while (pq.Count > 0)
                {
                    pq.TryDequeue(out var st, out int d);

                    if (d != dist[st])
                        continue;

                    // Goal reached
                    if (st.Mask == FULL)
                    {
                        finalState = st;
                        break;
                    }

                    var loc = locations[st.Id];

                    foreach (var conn in loc.connections)
                    {
                        string nextId = conn.destination;
                        int nextIndex = index[nextId];

                        int nextMask = st.Mask | (1 << nextIndex);
                        var nextState = new State(nextId, nextMask);

                        int nextDist = d + conn.distance;

                        if (!dist.ContainsKey(nextState) || nextDist < dist[nextState])
                        {
                            dist[nextState] = nextDist;
                            parent[nextState] = st;
                            parentConn[nextState] = conn;
                            pq.Enqueue(nextState, nextDist);
                        }
                    }
                }

                if (finalState == null)
                    return null;

                // Reconstruct path
                var nodes = new List<Location>();
                var cur = finalState;

                while (parent.ContainsKey(cur))
                {
                    nodes.Add(locations[cur.Id]);
                    cur = parent[cur];
                }

                nodes.Add(locations[cur.Id]);
                nodes.Reverse();

                return new Route
                {
                    Path = nodes,
                    TotalDistance = dist[finalState]
                };
            }
        }

    }



}
